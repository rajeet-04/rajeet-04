#!/usr/bin/env node
const fs = require('fs');
const path = require('path');
const fetch = global.fetch || require('node-fetch');

const REPO_TABLE_START = '<!-- REPO_TABLE_START -->';
const REPO_TABLE_END = '<!-- REPO_TABLE_END -->';
const README_PATH = path.join(__dirname, '..', 'README.md');

const token = process.env.GH_PAT || process.env.GITHUB_TOKEN;
if (!token) {
  console.error('Error: No GH_PAT or GITHUB_TOKEN provided in environment. Exiting.');
  process.exit(1);
}

async function fetchAllRepos() {
  const per_page = 100;
  let page = 1;
  let results = [];
  while (true) {
    const url = `https://api.github.com/user/repos?per_page=${per_page}&page=${page}&type=all&sort=updated`;
    const res = await fetch(url, { headers: { Authorization: `token ${token}`, 'User-Agent': 'update-repos-script' } });
    if (!res.ok) {
      const txt = await res.text();
      throw new Error(`GitHub API error ${res.status}: ${txt}`);
    }
    const json = await res.json();
    results = results.concat(json);
    if (json.length < per_page) break;
    page++;
  }
  return results;
}

function formatDate(iso) {
  if (!iso) return '-';
  const d = new Date(iso);
  return d.toLocaleDateString('en-GB');
}

function buildTable(repos) {
  // Header
  let md = '';
  md += REPO_TABLE_START + '\n';
  md += 'Below is a combined list (public + private) pulled from your GitHub summary. This section is auto-generated by a GitHub Action; do not edit it manually.\n\n';
  md += '| Name | Visibility | Language | Last Updated | Notes |\n';
  md += '|------|------------|----------|--------------|-------|\n';
  repos.forEach(r => {
    const name = `[${r.name}](${r.html_url})`;
    const vis = r.private ? 'Private' : (r.fork ? 'Public (fork)' : 'Public');
    const lang = r.language || '-';
    const updated = formatDate(r.updated_at);
    let notes = [];
    if (r.archived) notes.push('archived');
    if (r.fork && r.parent) notes.push(`forked from ${r.parent.full_name}`);
    if (r.license && r.license.spdx_id) notes.push(r.license.spdx_id);
    const noteStr = notes.join('; ') || '';
    md += `| ${name} | ${vis} | ${lang} | ${updated} | ${noteStr} |\n`;
  });
  md += '\n' + REPO_TABLE_END + '\n';
  return md;
}

async function main() {
  try {
    console.log('Fetching repos...');
    const repos = await fetchAllRepos();
    // sort by updated desc
    repos.sort((a,b) => new Date(b.updated_at) - new Date(a.updated_at));
    const table = buildTable(repos);

    const readme = fs.readFileSync(README_PATH, 'utf8');
    const start = readme.indexOf(REPO_TABLE_START);
    const end = readme.indexOf(REPO_TABLE_END);
    if (start === -1 || end === -1) {
      console.error('Markers not found in README.md. Make sure <!-- REPO_TABLE_START --> and <!-- REPO_TABLE_END --> exist.');
      process.exit(1);
    }
    const before = readme.slice(0, start);
    const after = readme.slice(end + REPO_TABLE_END.length);
    const newReadme = before + table + after;
    if (newReadme !== readme) {
      fs.writeFileSync(README_PATH, newReadme, 'utf8');
      console.log('README.md updated.');
      process.exit(0);
    } else {
      console.log('No changes to README.md.');
      process.exit(0);
    }
  } catch (err) {
    console.error('Error:', err.message || err);
    process.exit(2);
  }
}

main();
